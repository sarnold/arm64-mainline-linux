From 942e0b1202f9517ef073532b685d65df9bb97ee6 Mon Sep 17 00:00:00 2001
From: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date: Tue, 31 Mar 1970 04:50:11 +0100
Subject: [PATCH 106/173] media: qcom: camss: Add CSID Gen2 debugfs support

Add in the ability to export registers of interest read-only via debugfs
for the CSID-Gen2 block.

We can extend this out to other CSID versions later.

Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
---
 .../platform/qcom/camss/camss-csid-gen2.c     | 44 ++++++++++++++
 .../media/platform/qcom/camss/camss-csid.c    | 60 +++++++++++++++++--
 .../media/platform/qcom/camss/camss-csid.h    |  9 +++
 3 files changed, 107 insertions(+), 6 deletions(-)

diff --git a/drivers/media/platform/qcom/camss/camss-csid-gen2.c b/drivers/media/platform/qcom/camss/camss-csid-gen2.c
index 981a441c4a8c..6b1e1299910f 100644
--- a/drivers/media/platform/qcom/camss/camss-csid-gen2.c
+++ b/drivers/media/platform/qcom/camss/camss-csid-gen2.c
@@ -623,6 +623,49 @@ static void csid_subdev_init(struct csid_device *csid)
 	csid->testgen.nmodes = CSID_PAYLOAD_MODE_NUM_SUPPORTED_GEN2;
 }
 
+static size_t csid_dump_regs(struct csid_device *csid, char *buf, size_t buf_len)
+{
+	size_t len = 0;
+	int i;
+	struct vfe_device *vfe = &csid->camss->vfe[csid->id];
+
+	len += scnprintf(buf + len, buf_len - len,
+			 "CSID_TOP_IRQ_STATUS 0x%08x\n",
+			 readl_relaxed(csid->base + CSID_TOP_IRQ_STATUS));
+
+	len += scnprintf(buf + len, buf_len - len,
+			 "CSID_CSI2_RX_IRQ_STATUS 0x%08x\n",
+			 readl_relaxed(csid->base + CSID_CSI2_RX_IRQ_STATUS));
+
+	len += scnprintf(buf + len, buf_len - len,
+			 "CSID_CSI2_RX_CFG0 0x%08x\n",
+			 readl_relaxed(csid->base + CSID_CSI2_RX_CFG0));
+
+	len += scnprintf(buf + len, buf_len - len,
+			 "CSID_CSI2_RX_CFG1 0x%08x\n",
+			 readl_relaxed(csid->base + CSID_CSI2_RX_CFG1));
+
+	len += scnprintf(buf + len, buf_len - len,
+			 "CSID_CSI2_RX_TOTAL_PKTS_RCVD 0x%08x\n",
+			 readl_relaxed(csid->base + CSID_CSI2_RX_TOTAL_PKTS_RCVD));
+
+	len += scnprintf(buf + len, buf_len - len,
+			 "CSID_CSI2_RX_STATS_ECC 0x%08x\n",
+			 readl_relaxed(csid->base + CSID_CSI2_RX_STATS_ECC));
+
+	len += scnprintf(buf + len, buf_len - len,
+			 "CSID_CSI2_RX_CRC_ERRORS 0x%08x\n",
+			 readl_relaxed(csid->base + CSID_CSI2_RX_CRC_ERRORS));
+
+	for (i = 0; i < vfe->line_num; i++) {
+		len += scnprintf(buf + len, buf_len - len,
+				 "CSID_CSI2_RDIN_IRQ_STATUS(%d) 0x%08x\n",
+				 i, readl_relaxed(csid->base + CSID_CSI2_RDIN_IRQ_STATUS(i)));
+	}
+
+	return len;
+}
+
 const struct csid_hw_ops csid_ops_gen2 = {
 	.configure_stream = csid_configure_stream,
 	.configure_testgen_pattern = csid_configure_testgen_pattern,
@@ -631,4 +674,5 @@ const struct csid_hw_ops csid_ops_gen2 = {
 	.reset = csid_reset,
 	.src_pad_code = csid_src_pad_code,
 	.subdev_init = csid_subdev_init,
+	.dump_regs = csid_dump_regs,
 };
diff --git a/drivers/media/platform/qcom/camss/camss-csid.c b/drivers/media/platform/qcom/camss/camss-csid.c
index d393618ed54c..667c4f96f2bf 100644
--- a/drivers/media/platform/qcom/camss/camss-csid.c
+++ b/drivers/media/platform/qcom/camss/camss-csid.c
@@ -9,6 +9,7 @@
  */
 #include <linux/clk.h>
 #include <linux/completion.h>
+#include <linux/debugfs.h>
 #include <linux/interrupt.h>
 #include <linux/io.h>
 #include <linux/kernel.h>
@@ -161,6 +162,8 @@ static int csid_set_power(struct v4l2_subdev *sd, int on)
 	struct vfe_device *vfe = &camss->vfe[csid->id];
 	int ret = 0;
 
+	mutex_lock(&csid->mutex);
+
 	if (on) {
 		/*
 		 * From SDM845 onwards, the VFE needs to be powered on before
@@ -169,17 +172,17 @@ static int csid_set_power(struct v4l2_subdev *sd, int on)
 		 */
 		ret = vfe_get(vfe);
 		if (ret < 0)
-			return ret;
+			goto error;
 
 		ret = pm_runtime_resume_and_get(dev);
 		if (ret < 0)
-			return ret;
+			goto error;
 
 		ret = regulator_bulk_enable(csid->num_supplies,
 					    csid->supplies);
 		if (ret < 0) {
 			pm_runtime_put_sync(dev);
-			return ret;
+			goto error;
 		}
 
 		ret = csid_set_clock_rates(csid);
@@ -187,7 +190,7 @@ static int csid_set_power(struct v4l2_subdev *sd, int on)
 			regulator_bulk_disable(csid->num_supplies,
 					       csid->supplies);
 			pm_runtime_put_sync(dev);
-			return ret;
+			goto error;
 		}
 
 		ret = camss_enable_clocks(csid->nclocks, csid->clock, dev);
@@ -195,7 +198,7 @@ static int csid_set_power(struct v4l2_subdev *sd, int on)
 			regulator_bulk_disable(csid->num_supplies,
 					       csid->supplies);
 			pm_runtime_put_sync(dev);
-			return ret;
+			goto error;
 		}
 
 		csid->phy.need_vc_update = true;
@@ -209,11 +212,13 @@ static int csid_set_power(struct v4l2_subdev *sd, int on)
 			regulator_bulk_disable(csid->num_supplies,
 					       csid->supplies);
 			pm_runtime_put_sync(dev);
-			return ret;
+			goto error;
 		}
 
 		csid->ops->hw_version(csid);
+		csid->active = true;
 	} else {
+		csid->active = false;
 		disable_irq(csid->irq);
 		camss_disable_clocks(csid->nclocks, csid->clock);
 		regulator_bulk_disable(csid->num_supplies,
@@ -222,6 +227,8 @@ static int csid_set_power(struct v4l2_subdev *sd, int on)
 		vfe_put(vfe);
 	}
 
+error:
+	mutex_unlock(&csid->mutex);
 	return ret;
 }
 
@@ -810,6 +817,40 @@ static const struct media_entity_operations csid_media_ops = {
 	.link_validate = v4l2_subdev_link_validate,
 };
 
+static ssize_t read_file_csid_dump_regs(struct file *file,
+					char __user *user_buf,
+					size_t count, loff_t *ppos)
+{
+	struct csid_device *csid = file->private_data;
+	size_t len = 0, buf_len = 2048;
+	char *buf;
+	int ret;
+
+	buf = kzalloc(buf_len, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	mutex_lock(&csid->mutex);
+
+	if (csid->active)
+		len = csid->ops->dump_regs(csid, buf, buf_len);
+	else
+		len = scnprintf(buf + len, buf_len - len, "%s %s\n",
+				csid->irq_name,
+				csid->active ? "active" : "inactive");
+	ret = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+	kfree(buf);
+
+	mutex_unlock(&csid->mutex);
+
+	return ret;
+}
+
+static const struct file_operations fops_csid_dump_regs = {
+	.open = simple_open,
+	.read = read_file_csid_dump_regs,
+};
+
 /*
  * msm_csid_register_entity - Register subdev node for CSID module
  * @csid: CSID device
@@ -826,6 +867,7 @@ int msm_csid_register_entity(struct csid_device *csid,
 	int i;
 	int ret;
 
+	mutex_init(&csid->mutex);
 	v4l2_subdev_init(sd, &csid_v4l2_ops);
 	sd->internal_ops = &csid_v4l2_internal_ops;
 	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |
@@ -877,6 +919,12 @@ int msm_csid_register_entity(struct csid_device *csid,
 		goto media_cleanup;
 	}
 
+	if (csid->camss->debugfs_rootdir) {
+		debugfs_create_file(csid->irq_name, 0200,
+				    csid->camss->debugfs_rootdir, csid,
+				    &fops_csid_dump_regs);
+	}
+
 	return 0;
 
 media_cleanup:
diff --git a/drivers/media/platform/qcom/camss/camss-csid.h b/drivers/media/platform/qcom/camss/camss-csid.h
index fddccb69da13..e841d667508f 100644
--- a/drivers/media/platform/qcom/camss/camss-csid.h
+++ b/drivers/media/platform/qcom/camss/camss-csid.h
@@ -12,6 +12,7 @@
 
 #include <linux/clk.h>
 #include <linux/interrupt.h>
+#include <linux/mutex.h>
 #include <media/media-entity.h>
 #include <media/v4l2-ctrls.h>
 #include <media/v4l2-device.h>
@@ -147,6 +148,12 @@ struct csid_hw_ops {
 	 * @csid: CSID device
 	 */
 	void (*subdev_init)(struct csid_device *csid);
+
+	/*
+	 * dump_regs - Show debugfs regs on a per CSID basis
+	 * @csid: CSID device
+	 */
+	size_t (*dump_regs)(struct csid_device *csid, char *buf, size_t buf_len);
 };
 
 struct csid_device {
@@ -170,6 +177,8 @@ struct csid_device {
 	const struct csid_format *formats;
 	unsigned int nformats;
 	const struct csid_hw_ops *ops;
+	struct mutex mutex;	/* atomicity of active flag */
+	bool active;
 };
 
 struct camss_subdev_resources;
-- 
2.43.0

